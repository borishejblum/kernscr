[{"path":"http://borishejblum.github.io/kernscr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matey Neykov. Author. Boris P Hejblum. Author, maintainer. Jennifer Sinnot. Author.","code":""},{"path":"http://borishejblum.github.io/kernscr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Neykov M, Hejblum BP Sinnott JA (2018). Kernel Machine Score Test Pathway Analysis Presence Semi-Competing Risks. Statistical Methods Medical Research, 27(4): 1099-1114. <doi: 10.1177/0962280216653427>","code":"@Article{,   title = {Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks},   author = {Matey Neykov and Boris P Hejblum and Jennifer A Sinnott},   journal = {Statistical Methods in Medical Research},   year = {2018},   volume = {27},   number = {4},   pages = {1099-1114},   doi = {10.1177/0962280216653427},   note = {R package version 1.0.5}, }"},{"path":"http://borishejblum.github.io/kernscr/index.html","id":"kernscr","dir":"","previous_headings":"","what":"Kernel Machine Score Test for Semi-Competing Risks","title":"Kernel Machine Score Test for Semi-Competing Risks","text":"kernscr R package performs score test genetic pathway analysis presence semi-competing risks. Neykov M, Hejblum BP Sinnott JA (2018). Kernel Machine Score Test Pathway Analysis Presence Semi-Competing Risks. Statistical Methods Medical Research, 27(4): 1099-1114. <doi: 10.1177/0962280216653427>","code":""},{"path":"http://borishejblum.github.io/kernscr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Kernel Machine Score Test for Semi-Competing Risks","text":"can install released version kernscr CRAN :","code":"install.packages(\"kernscr\")"},{"path":"http://borishejblum.github.io/kernscr/reference/Ahat.html","id":null,"dir":"Reference","previous_headings":"","what":"Ahat computation — Ahat","title":"Ahat computation — Ahat","text":"Ahat computation","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/Ahat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ahat computation — Ahat","text":"","code":"Ahat(all_times, failures, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/M_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"M vector and its perturbation — M_vec","title":"M vector and its perturbation — M_vec","text":"M vector perturbation M vector perturbation","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/M_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"M vector and its perturbation — M_vec","text":"","code":"M_vec(t, all_times, failures, gamma_vec, U)  M_vec_pert(perturb_mat, t, all_times, failures, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/PI_0.html","id":null,"dir":"Reference","previous_headings":"","what":"PI_0 — PI_0","title":"PI_0 — PI_0","text":"PI_0","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/PI_0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PI_0 — PI_0","text":"","code":"PI_0(t, all_times, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/PI_1.html","id":null,"dir":"Reference","previous_headings":"","what":"PI_2 — PI_1","title":"PI_2 — PI_1","text":"PI_2","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/PI_1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PI_2 — PI_1","text":"","code":"PI_1(t, all_times, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/PI_2.html","id":null,"dir":"Reference","previous_headings":"","what":"PI_2 — PI_2","title":"PI_2 — PI_2","text":"PI_2","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/PI_2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PI_2 — PI_2","text":"","code":"PI_2(t, all_times, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/VTM.html","id":null,"dir":"Reference","previous_headings":"","what":"VTM — VTM","title":"VTM — VTM","text":"Repeats vector identical rows matrix","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/VTM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"VTM — VTM","text":"","code":"VTM(vc, dm)"},{"path":"http://borishejblum.github.io/kernscr/reference/VTM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"VTM — VTM","text":"vc vector repeated dm number times vc repeated","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/VTM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"VTM — VTM","text":"matrix dm rows","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/cancer_pathways.html","id":null,"dir":"Reference","previous_headings":"","what":"70 pathways from MSigDB c2CP — cancer_pathways","title":"70 pathways from MSigDB c2CP — cancer_pathways","text":"70 pathways MSigDB c2CP","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/cancer_pathways.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"70 pathways from MSigDB c2CP — cancer_pathways","text":"","code":"data(\"cancer_pathways\")"},{"path":"http://borishejblum.github.io/kernscr/reference/cancer_pathways.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"70 pathways from MSigDB c2CP — cancer_pathways","text":"list 70 relevant pathways old version MSigDB c2CP containing Entrez IDs.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/cancer_pathways.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"70 pathways from MSigDB c2CP — cancer_pathways","text":"MJ van de Vijver,YD , LJ van't Veer, H Dai, AAM Hart, DW Voskuil, gene-expression signature predictor survival breast cancer, New England Journal Medicine, 347(25):1999-2009, 2002. T Cai, G Tonini, X Lin, Kernel Machine Approach Testing Significance Multiple Genetic Markers Risk Prediction, Biometrics, 67(3):975-986, 2011.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/cancer_pathways.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"70 pathways from MSigDB c2CP — cancer_pathways","text":"","code":"data(\"cancer_pathways\")  if(interactive()){ ##get the data from Vijver publication  #clinical data import_xls_from_zip <- function(urlPath, filename, zipname, skip=0){  zipFile <- paste0(zipname, \".zip\")  download.file(paste0(urlPath, zipFile), zipFile)  unzip(zipFile, exdir=\"./temp_unzip\")  xlsFile <- paste0(\"./temp_unzip/\", filename, \".xls\")  res <- readxl::read_xls(xlsFile, skip=skip)  unlink(zipFile)  unlink(\"./temp_unzip\", recursive=TRUE)  return(res) }  BC_dat_clin <- import_xls_from_zip2(urlPath=\"http://ccb.nki.nl/data/\",                                   filename=\"Table1_ClinicalData_Table\",                                   zipname=\"nejm_table1\",                                   skip=2                                   ) BC_dat_clin <- BC_dat_clin[order(BC_dat_clin$SampleID), ] col2rmv <- 1:ncol(BC_dat_clin) BC_dat_clin$ID <- paste0(\"S\", BC_dat_clin$SampleID) rownames(BC_dat_clin) <- BC_dat_clin$ID BC_dat_clin$evdeath <- BC_dat_clin$EVENTdeath BC_dat_clin$tsurv <- BC_dat_clin$TIMEsurvival BC_dat_clin$evmeta <- BC_dat_clin$EVENTmeta BC_dat_clin$tmeta<- pmin(BC_dat_clin$TIMEsurvival, BC_dat_clin$TIMEmeta, na.rm=TRUE) samples2rmv <- c(\"S28\", \"S122\", \"S123\", \"S124\", \"S133\", \"S138\", \"S139\", \"S141\", \"S221\", \"S222\",                 \"S224\", \"S226\", \"S227\", \"S228\", \"S229\", \"S230\", \"S231\", \"S237\", \"S238\", \"S240\",                 \"S241\", \"S248\", \"S250\", \"S251\", \"S252\", \"S254\", \"S292\", \"S317\", \"S342\", \"S371\",                 \"S379\", \"S380\", \"S397\", \"S398\", \"S401\") BC_dat_clin <- BC_dat_clin[-which(BC_dat_clin$ID %in% samples2rmv), -col2rmv] head(BC_dat_clin)    #import genomics data urlPath=\"http://ccb.nki.nl/data/\" zipFile <- paste0(\"ZipFiles295Samples\", \".zip\") download.file(paste0(urlPath, zipFile), zipFile) unzip(zipFile, exdir=\"./temp_unzip\") unlink(zipFile) unlink(\"./temp_unzip/Readme.txt\", recursive=FALSE) txtfiles <- list.files(\"./temp_unzip/\") BC_dat_exp <- NULL for(f in txtfiles){  temp_exp <- read.delim(paste0(\"./temp_unzip/\", f))  if(f==txtfiles[1]){    gene_id <- as.character(temp_exp[-1, 1])    gene_symbol <- as.character(temp_exp[-1, 2])  }  temp_exp <- temp_exp[-1, grep(\"Sample.\", colnames(temp_exp))]  colnames(temp_exp) <- gsub(\"Sample.\", \"S\", colnames(temp_exp))  if(f==txtfiles[1]){    BC_dat_exp <- temp_exp  }else{    BC_dat_exp <- cbind(BC_dat_exp, temp_exp)  } } BC_dat_exp_all <- cbind.data.frame(\"SYMBOL\"=gene_symbol, BC_dat_exp[,  BC_dat_clin$ID]) unlink(\"./temp_unzip\", recursive=TRUE)  # translating the pathways from Entrez ID to gene symbol if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)){  library(org.Hs.eg.db)  x <- org.Hs.egSYMBOL  mapped_genes <- mappedkeys(x)  xx <- as.list(x[mapped_genes])  cancer_pathways_Symbol <- lapply(cancer_pathways, function(v){unlist(xx[v])})  sapply(cancer_pathways, function(x){length(intersect(x, rownames(BC_dat_exp)))/length(x)}) } }"},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Testing pathway risk association — compute_all_tests","title":"Testing pathway risk association — compute_all_tests","text":"functions computes p-values frm score tests genetic pathway risk association 5 different models","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Testing pathway risk association — compute_all_tests","text":"","code":"compute_all_tests(   data,   ind_gene = 7:ncol(data),   num_perts = 1000,   Ws = NULL,   rho = NA,   kernel = c(\"linear\", \"gaussian\", \"poly\"),   d = 2,   pca_thres = 0.9,   get_ptb_pvals = FALSE,   ... )"},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Testing pathway risk association — compute_all_tests","text":"data data.frame N rows set output sim_SCR_data columns: XR: time recurrence / death / censoring XD: time death / censoring DeltaR: indicator censoring (0), recurrence (1), death (2) earliest time XR DeltaD: indicator censoring (0) death (1) XPFS: time recurrence / death / censoring (=XR) DeltaPFS: indicator censoring (0) recurrence death, whichever came first (1) Z_1,...,Z_P: genomic variables ind_gene columns indices genes pathway interest. Default 7:ncol(data)). num_perts number perturbations used. Default 1000. Ws optional inputed perturbations, vector length N x num_perts containing ..d. realization random variable mean=0 variance=1. rho vector rhos, one found created range returned findRhoInterval, used tuning non-linear kernel. used kernel \"linear\". Default NA. Currently available use user-defined kernels. kernel character string indicating kernel used. Possible values (currently implemented) \"linear\", \"gaussian\" \"poly\". Otherwise, can also user defined kernel function. See genericKernelEval. d kernel \"poly\", polynomial power. Default 2 (quadratic kernel). pca_thres number 0 1 giving threshold used PCA. Default 0.9. NULL, PCA performed. get_ptb_pvals logical flag indicating whether perturbed p-values returned part results. Default FALSE. ... extra parameters passed user-defined kernel.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Testing pathway risk association — compute_all_tests","text":"either vector p-values 5 different models names: \"SCR\": Semi-Competing Risks \"PFS\": Progression Free Survival \"CR\": Competing Risks \"OS\": Overall Survival \"SCR_alt\": SCR allowing different tuning parameters two event time processes else get_ptb_pvals TRUE, list 2 elements: \"obs_pvals\": vector containing observed p-values 5 models described \"null_pvals_perts\": matrix dimensions num_perts x 5 containing corresponding perturbed p-values","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Testing pathway risk association — compute_all_tests","text":"Neykov M, Hejblum BP, Sinnot JA, Kernel Machine Score Test Pathway Analysis Presence Semi-Competing Risks, submitted, 2016.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/compute_all_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Testing pathway risk association — compute_all_tests","text":"","code":"## First generate some Data feat_m_fun <- function(X){  sin(X[,1]+X[,2]^2)-1 } feat_d_fun <-  function(X){  (X[,4]-X[,5])^2/8 } mydata <- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,                       feat_d = feat_d_fun, mu_cen = 40, cov=0.5)  #initial range ind_gene <- c(7:ncol(mydata)) my_rho_init <- seq(0.01, 20, length=300)*length(ind_gene) range(my_rho_init) #> [1]   0.2 400.0  if(interactive()){ # compute the interval for rho rho_set <- findRhoInterval(tZ=t(mydata[,ind_gene]), rho_init = my_rho_init, kernel=\"gaussian\") rho_set range(my_rho_init) # good to check that the interval produced here is strictly contained in rho_init # otherwise, expand rho.init and rerun  rhos <- exp(seq(log(rho_set[1]),log(rho_set[2]), length=50))  # run the tests with Gaussian kernel compute_all_tests(data = mydata, num_perts=1000, rho=rhos, kernel=\"gaussian\") # run the tests with linear kernel compute_all_tests(data=mydata, num_perts=1000, kernel=\"linear\") }"},{"path":"http://borishejblum.github.io/kernscr/reference/dM.html","id":null,"dir":"Reference","previous_headings":"","what":"dM — dM","title":"dM — dM","text":"dM","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/dM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"dM — dM","text":"","code":"dM(all_times, failures, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"Find interval constraining rho parameter non linear kernel","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"","code":"findRhoInterval(   tZ,   rho_init = seq(0.01, 20, length = 300) * nrow(tZ),   kernel = c(\"gaussian\", \"poly\"),   d = NA,   rate_range = c(1.5, 4),   pca_thres = 0.9,   warning_suppress = TRUE )"},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"tZ P x N matrix genomic covariates (.e., usual data array Z transposed) rho_init initial large range possible rhos, considered see reasonable tuning parameters kernel. Default seq(0.01, 20, length=300)*P. See Details. kernel character string specifying nonlinear kernel. Currently supported options : \"gaussian\" \"poly\" d kernel \"poly\", polynomial power (e.g. d=2 quadratic kernel). Default NA. rate_range vector length 2 indicating range alpha paper. Default c(1.5,4). pca_thres number 0 1 giving threshold used PCA. Default 0.9. NULL, PCA performed. warning_suppress logical flag. Indicating whether warnings suppress linear model fitting step. Default TRUE. See details.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"upper lower bound look rho","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"function print rho_init range range valid tuning parameters. range butts either upper lower bound rho_init, can rerun function bigger rho_init. Finding right tuning parameters includes step fitting linear model can fail tuning parameters yield one eigenvector. want eliminate tuning parameters, OK. However, case one want suppress (numerous) annoying warning messages, use warning_suppress argument.","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/findRhoInterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find an interval constraining the rho parameter for a non linear kernel — findRhoInterval","text":"","code":"## First generate some Data feat_m_fun <- function(X){  sin(X[,1]+X[,2]^2)-1 } feat_d_fun <-  function(X){  (X[,4]-X[,5])^2/8 } mydata <- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,                       feat_d = feat_d_fun, mu_cen = 30, cov=0.5)  #initial range ind_gene <- c(7:ncol(mydata)) my_rho_init <- seq(0.01, 20, length=300)*length(ind_gene) range(my_rho_init) #> [1]   0.2 400.0  if(interactive()){ # compute the interval for rho rho_set <- findRhoInterval(tZ=t(mydata[,ind_gene]), rho_init = my_rho_init, kernel=\"gaussian\") rho_set range(my_rho_init) # good to check that the interval produced here is strictly contained in rho_init # otherwise, expand rho.init and rerun  #rhos <- exp(seq(log(rho_set[1]),log(rho_set[2]), length=50)) }"},{"path":"http://borishejblum.github.io/kernscr/reference/kernelEval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation of kernels — kernelEval","title":"Evaluation of kernels — kernelEval","text":"Evaluation kernels","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernelEval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation of kernels — kernelEval","text":"","code":"kernelEval(tZ, kernel = c(\"linear\", \"poly\", \"gaussian\"), ...)  linKernelEval(tZ)  gaussKernelEval(tZ, sigma = 1)  polyKernelEval(tZ, a = 0, d = 2)  genericKernelEval(tZ, kernel_func, ...)  gaussKernelEval_multipleRhos(tZ, rho)  polyKernelEval_multipleRhos(tZ, rho, d = 2)"},{"path":"http://borishejblum.github.io/kernscr/reference/kernelEval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluation of kernels — kernelEval","text":"tZ P x N matrix genomic covariates (.e., usual data array Z transposed) kernel kernel evaluated kerneval. Possible values include currently implemented kernels designated character string \"linear\", \"poly\" \"gaussian\". Otherwise can also user-defined function (see kernel_func). ... arguments passed passed evaluated kernel function. sigma standard-deviation parameter \"gaussian\" kernel. TODO polynomial \"poly\". Default 0 d power polynomial.  Default 2 (quadratic kernel). kernel_func function, whose first argument tZ rho either single rho evaluate kernel , vector rhos","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernelEval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluation of kernels — kernelEval","text":"kernelEval, linKernelEval, gaussKernelEval, genericKernelEval return N x N matrix entries K(Z[,], Z[j,]) [persons ,j] gaussKernelEval_multipleRhos polyKernelEval_multipleRhos return matrix dimension Q x N^2, Q length rho, row corresponds rho (puns!) get actual kernel matrix associated particular value rho, output G, take matrix(G[,], N)","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernelEval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluation of kernels — kernelEval","text":"kernelEval works gaussian, polynomial linear kernels currently. genericKernelEval polyKernelEval_multipleRhos, one rho > 0 get basis monomials degree d","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernscr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks — kernscr-package","title":"kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks — kernscr-package","text":"Kernel Machine Score Test Pathway Analysis Presence Semi-Competing Risks","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernscr-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks — kernscr-package","text":"main function kernscr package compute_all_tests","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/kernscr-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks — kernscr-package","text":"Neykov M, Hejblum BP, Sinnot JA, Kernel Machine Score Test Pathway Analysis Presence Semi-Competing Risks, Stat Methods Med Res, , 27(4): 1099-1114 (2018). <doi: 10.1177/0962280216653427>.","code":""},{"path":[]},{"path":"http://borishejblum.github.io/kernscr/reference/kernscr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks — kernscr-package","text":"Matey Neykov, Boris P. Hejblum, Jennifer . Sinnott — Maintainer: Boris P. Hejblum","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Lambda and its perturbation — lambda","title":"Lambda and its perturbation — lambda","text":"Lambda perturbation","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/lambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lambda and its perturbation — lambda","text":"","code":"lambda(t, all_times, failures, gamma_vec, U)  lambda_pert(t, perturb_mat, all_times, failures, gamma_vec, U)"},{"path":"http://borishejblum.github.io/kernscr/reference/plot_kernscr.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting functions used in the manuscript — plot_kernscr_methodsplit","title":"Plotting functions used in the manuscript — plot_kernscr_methodsplit","text":"Plotting functions used manuscript","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/plot_kernscr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting functions used in the manuscript — plot_kernscr_methodsplit","text":"","code":"plot_kernscr_methodsplit(   raw_melted,   adj_melted,   kernel,   method,   pathway_names = TRUE,   title = NULL,   raw_lower_threshold = round(log10(1/10000), 1),   adj_lower_threshold = round(log10(1/10000 * 70), 1) )  plot_kernscr_kernelsplit(   raw_melted,   adj_melted,   kernel,   method,   pathway_names = TRUE,   title = NULL,   raw_lower_threshold = round(log10(1/10000), 1),   adj_lower_threshold = NULL )"},{"path":"http://borishejblum.github.io/kernscr/reference/sim_SCR_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data Simulation Function — sim_SCR_data","title":"Data Simulation Function — sim_SCR_data","text":"Data Simulation Function","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/sim_SCR_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data Simulation Function — sim_SCR_data","text":"","code":"sim_SCR_data(   data_size,   ncol_gene_mat,   feat_m,   feat_d,   mu_cen,   cov,   lam_m = 1/15,   lam_d = 1/20,   norm_vcov = c(1, 0.5, 0.5, 1) )"},{"path":"http://borishejblum.github.io/kernscr/reference/sim_SCR_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data Simulation Function — sim_SCR_data","text":"data_size integer giving simulated sample size N ncol_gene_mat integer giving simulated number genomic covariates P feat_m function transforms genomic features signal metastasis process. function matrix dimensions N X P argument. feat_d function transforms genomic features signal death process. function matrix dimensions N X P argument. mu_cen mean exponential censoring process cov correlation genomic covariates lam_m baseline hazard constant metastasis process. Default 1/15. lam_d baseline hazard constant death process. Default 1/20. norm_vcov vector length 4 correlation errors two processes normal scale complementary-log-log-transformed. Default c(1,.5,.5,1).","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/sim_SCR_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data Simulation Function — sim_SCR_data","text":"data.frame columns: XR: time recurrence / death / censoring XD: time death / censoring DeltaR: Indicator censoring (0), recurrence (1), death (2) earliest time XR DeltaD: Indicator censoring (0) death (1) XPFS: time recurrence / death / censoring (=XR) DeltaPFS: Indicator censoring (0) recurrence death, whichever came first (1) Z_1,...,Z_P: genomic variables","code":""},{"path":"http://borishejblum.github.io/kernscr/reference/sim_SCR_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data Simulation Function — sim_SCR_data","text":"","code":"feat_m_fun <- function(X){  sin(X[,1]+X[,2]^2)-1 } feat_d_fun <-  function(X){  (X[,4]-X[,5])^2/8 } mydata <- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,                       feat_d = feat_d_fun, mu_cen = 30, cov=0.5) head(mydata) #>          XR        XD DeltaR DeltaD      XPFS DeltaPFS         Z1         Z2 #> 1 0.5709861 2.4814082      1      1 0.5709861        1  1.6770652  1.5743362 #> 2 1.5163527 1.5163527      2      1 1.5163527        1 -1.2338608  0.5868927 #> 3 0.1652146 0.1652146      2      1 0.1652146        1  0.5507934  2.2766250 #> 4 0.2217832 3.4893375      1      1 0.2217832        1 -1.7088872 -0.9537585 #> 5 9.0683920 9.0683920      0      0 9.0683920        0 -0.8922172 -2.7517212 #> 6 3.2246105 9.1677755      1      1 3.2246105        1  0.2947760 -0.5452931 #>           Z3         Z4         Z5          Z6         Z7          Z8 #> 1  0.6266552  0.8544716  0.7227750  1.92555530  1.1569134  0.61924342 #> 2 -0.5375776 -0.4399051 -0.2058055  0.06906448 -1.6975463  0.07777580 #> 3  0.6102380  1.7535212  1.6319498  0.85224296  0.2973967 -0.02851258 #> 4 -1.5727263 -2.4843322 -0.6132310 -1.32448233 -0.2335242 -1.55701726 #> 5 -1.4866415 -1.5619629 -1.8428550 -2.16518436 -1.9271633 -2.33975721 #> 6  0.3670728  0.4162541  0.1771264 -1.40868217 -0.4391026  0.70198096 #>           Z9         Z10        Z11         Z12         Z13         Z14 #> 1  0.2803083 -0.08408994  1.5539434  1.82080564  0.45177478  0.07200551 #> 2 -0.5754064  1.97568142  1.0432724 -0.03277913  0.09001714 -0.33355545 #> 3  0.1124842  0.40535076  0.6198172  1.63618018  1.61638878  1.04235854 #> 4 -0.2614641 -1.16118224 -1.1061088 -0.99850346 -0.49357495 -0.32581411 #> 5 -0.4264133 -1.20871035 -1.8618217 -1.14293186 -1.50403067 -2.37417735 #> 6  0.9690748 -0.81080633 -0.4232620 -1.20023125  0.94697504  0.15197085 #>          Z15         Z16        Z17         Z18         Z19        Z20 #> 1  1.2168023  0.78918968  0.9433729  1.31135049 -0.23626618 -0.1302273 #> 2 -0.1253046  0.09027784 -0.9876235  0.01601721 -0.73692806 -1.0247439 #> 3  0.4852867  0.33546128  0.7489955  0.89570857  0.43647691  1.1516940 #> 4  0.4369060 -0.38818449 -1.1178843 -0.47653437 -1.15930012 -1.6188139 #> 5 -1.1207373 -0.76696977 -2.5409119 -1.76063718 -1.72002916 -0.6382582 #> 6  0.8285057 -0.26599286  0.4243545  0.39563953 -0.05744887  0.7798729 ## how many experience both events mean(mydata[,\"DeltaR\"]==1 & mydata[,\"DeltaD\"]==1) #> [1] 0.4175 ## how many only recur mean(mydata[,\"DeltaR\"]==1 & mydata[,\"DeltaD\"]==0) #> [1] 0.255 ## how many only die mean(mydata[,\"DeltaR\"]==2 & mydata[,\"DeltaD\"]==1) #> [1] 0.175 ## how many are censored mean(mydata[,\"DeltaR\"]==0 & mydata[,\"DeltaD\"]==0) #> [1] 0.1525"}]
